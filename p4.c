/* File:
 *           p4.c
 * Author:
 *           Ray Wang
 * Purpose:
 *           Implement parallel bitonic sort of a list that is either user
 *   		 input or generated by the program using a random number
 *   		 generator.
 *
 * Compile:
 *           mpicc -g -Wall -o p4 p4.c
 * Run:
 *           mpiexec -n <p> ./p4 <n> <'i'|'g'> (on lab machines)
 *           csmpiexec -n <p> ./p4 <n> <'i'|'g'> (on the penguin cluster)
 *
 * Input:
 *           p:  number of processes to use
 *           n:  size of array
 *           'i':   user will enter list
 *           'g': program will generate list
 * Output:
 *           The unsorted list and the sorted list
 *
 * Notes:
 *           1.  The number of processes, p, should evenly divide n.
 */

#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <string.h>

#define KEY_MAX 1000000
//#define DEBUG

int Read_n(int my_rank, MPI_Comm comm);
void Gen_list(int global[], int n, int my_rank, int loc_n, int loc_list[],
              MPI_Comm comm);
void Print_loc(int arr[], int n, int my_rank);
void Print_global(int arr[], int n);
void Get_args(int argc, char* argv[], int* n_p, char* ig_p, int my_rank);
void Read_array(int global[], int n, int my_rank, int loc_n, int loc_arr[],
                MPI_Comm comm);
void Bitonic_sort_decr(int loc_list[], int loc_rec[], int loc_merge[], int loc_n,
                       int max_stage, int my_rank, MPI_Comm comm);
void Bitonic_sort_incr(int loc_list[], int loc_rec[], int loc_merge[], int loc_n,
                       int max_stage, int my_rank, MPI_Comm comm);
void Butterfly(int my_rank, int loc_list[], int loc_rec[], int loc_merge[],
               int p, int loc_n, MPI_Comm comm);
int compare (const void * a, const void * b);
void Merge_low(int loc_list[], int loc_rec[], int loc_merge[], int loc_n,
               MPI_Comm comm);
void Merge_high(int loc_list[], int loc_rec[], int loc_merge[], int loc_n,
                MPI_Comm comm);

/*------------------------------- main ---------------------------------------*/
int main(int argc, char* argv[]) {
    MPI_Comm comm;
    int n, loc_n, p, my_rank;
    int *global, *loc_list, *loc_rec, *loc_merge;
    char ig;
    
    MPI_Init(&argc, &argv);
    comm = MPI_COMM_WORLD;
    MPI_Comm_size(comm, &p);
    MPI_Comm_rank(comm, &my_rank);
    
    Get_args(argc, argv, &n, &ig, my_rank);
    
    global = malloc(n*sizeof(int));
    loc_n = n/p;
    loc_list = malloc(loc_n*sizeof(int));
    loc_rec = malloc(loc_n*sizeof(int));
    loc_merge = malloc(loc_n*sizeof(int));
    
    if (ig == 'i') {
        Read_array(global, n, my_rank, loc_n, loc_list, comm);
    } else {
        Gen_list(global, n, my_rank, loc_n, loc_list, comm);
    }
    
    if (my_rank == 0) {
        printf("List to be sorted: \n");
        Print_global(global, n);
    }
    
    Butterfly(my_rank, loc_list, loc_rec, loc_merge, p, loc_n, comm);
    
    MPI_Gather(loc_list, loc_n, MPI_INT, global, loc_n, MPI_INT, 0, comm);
    
    if (my_rank == 0) {
        printf("Sorted list: \n");
        Print_global(global, n);
    }
    
    free(global);
    free(loc_list);
    free(loc_rec);
    free(loc_merge);
    
    MPI_Finalize();
    
    return 0;
} /* main */

/*---------------------------------------------------------------------
 * Function:  Butterfly
 * Purpose:   Calls increasing or decreasing bitonic sort
 * In args:   my_rank: rank of process
 *            loc_list[]: local subarray of each process
 *            loc_recv[]: array for each process to receive partner's subarray
 *            loc_merge[]: array that each process keeps after merge-split
 *            p: number of processes
 *            loc_n: size of subarray
 *            comm:  Communicator containing all calling processes
 */
void Butterfly(int my_rank, int loc_list[], int loc_rec[], int loc_merge[],
               int p, int loc_n, MPI_Comm comm) {
    
    unsigned and_bit;
    unsigned p_count;
    int max_stage;
    
    qsort(loc_list, loc_n, sizeof(int), compare);
    
    for (p_count = 2, and_bit = 2, max_stage = 1; p_count <= p;
         and_bit <<=1, p_count <<= 1, max_stage++) {
        if ((my_rank & and_bit) == 0) {
            Bitonic_sort_incr(loc_list, loc_rec, loc_merge, loc_n, max_stage,
                              my_rank, comm);
        } else {
            Bitonic_sort_decr(loc_list, loc_rec, loc_merge, loc_n, max_stage,
                              my_rank, comm);
        }
    }
    
} /* Butterfly */

/*---------------------------------------------------------------------
 * Function:    Bitonic_sort_incr
 * Purpose:     Use bitonic sort to sort the keys in loc_list into increasing
 *              order
 * In arg:      loc_recv[]: array for each process to receive partner's subarray
 *              loc_merge[]: array that each process keeps after merge-split
 *              loc_n; size of subarray
 *              max_stage: maximum number of stages per butterfly
 *              my_rank: rank of each process
 *              comm:  Communicator containing all calling processes
 * In/out arg:  loc_list[]: local subarray of each process
 */
void Bitonic_sort_incr(int loc_list[], int loc_rec[], int loc_merge[], int loc_n,
                       int max_stage, int my_rank, MPI_Comm comm) {
    
    int partner;
    int stage;
    unsigned bitmask = 1 << (max_stage - 1);
    
    /* This is the bitonic split */
    for (stage = 0; stage < max_stage; stage++) {
        partner = my_rank ^ bitmask;
        MPI_Sendrecv(loc_list, loc_n, MPI_INT, partner, 0, loc_rec, loc_n,
                     MPI_INT, partner, 0, comm, MPI_STATUS_IGNORE);
        if (my_rank < partner) {
            Merge_low(loc_list, loc_rec, loc_merge, loc_n, comm);
        } else {
            Merge_high(loc_list, loc_rec, loc_merge, loc_n, comm);
        }
        
#       ifdef DEBUG
        printf("Stage %d of Bitonic Incr\n", stage);
        Print_loc(loc_list, loc_n, my_rank);
        fflush(stdout);
#       endif
        
        bitmask >>= 1;
    }
    
} /* Bitonic_sort_incr */


/*---------------------------------------------------------------------
 * Function:    Bitonic_sort_decr
 * Purpose:     Use bitonic sort to sort the keys in loc_list into decreasing
 *              order
 * In arg:      loc_recv[]: array for each process to receive partner's subarray
 *              loc_merge[]: array that each process keeps after merge-split
 *              loc_n; size of subarray
 *              max_stage: maximum number of stages per butterfly
 *              my_rank: rank of each process
 *              comm:  Communicator containing all calling processes
 * In/out arg:  loc_list[]: local subarray of each process
 */
void Bitonic_sort_decr(int loc_list[], int loc_rec[], int loc_merge[], int loc_n,
                       int max_stage, int my_rank, MPI_Comm comm) {
    
    int partner;
    int stage;
    unsigned bitmask = 1 << (max_stage - 1);
    
    /* This is the bitonic split */
    for (stage = 0; stage < max_stage; stage++) {
        partner = my_rank ^ bitmask;
        MPI_Sendrecv(loc_list, loc_n, MPI_INT, partner, 0, loc_rec, loc_n,
                     MPI_INT, partner, 0, comm, MPI_STATUS_IGNORE);
        if (my_rank > partner) {
            Merge_low(loc_list, loc_rec, loc_merge, loc_n, comm);
        } else {
            Merge_high(loc_list, loc_rec, loc_merge, loc_n, comm);
        }
        
#       ifdef DEBUG
        printf("Stage %d of Bitonic Decr\n", stage);
        Print_loc(loc_list, loc_n, my_rank);
        fflush(stdout);
#       endif
        
        bitmask >>= 1;
    }
    
} /* Bitonic_sort_decr */

/*---------------------------------------------------------------------
 * Function:  Merge_low
 * Purpose:   Performs merge split and keeps smaller ints
 * In arg:    loc_recv[]: array for each process to receive partner's subarray
 *            loc_merge[]: array that each process keeps after merge-split
 *            loc_n; size of subarray
 *            comm:  Communicator containing all calling processes
 * In/out arg:  loc_list[]: local subarray of each process
 */
void Merge_low(int loc_list[], int loc_rec[], int loc_merge[], int loc_n,
               MPI_Comm comm) {
    
    int i = 0;
    int j = 0;
    int k;
    
    for (k = 0; k < loc_n; k++) {
        if (loc_list[i] <= loc_rec[j]) {
            loc_merge[k] = loc_list[i];
            i++;
        } else {
            loc_merge[k] = loc_rec[j];
            j++;
        }
    }
    
    memcpy(loc_list, loc_merge, loc_n*sizeof(int));
    
} /* Merge_low */

/*---------------------------------------------------------------------
 * Function:  Merge_high
 * Purpose:   Perform merge split and keeps higher ints
 * In arg:    loc_recv[]: array for each process to receive partner's subarray
 *            loc_merge[]: array that each process keeps after merge-split
 *            loc_n; size of subarray
 *            comm:  Communicator containing all calling processes
 * In/out arg:  loc_list[]: local subarray of each process
 */
void Merge_high(int loc_list[], int loc_rec[], int loc_merge[], int loc_n,
                MPI_Comm comm) {
    
    int i = loc_n - 1;
    int j = loc_n - 1;
    int k;
    
    for (k = loc_n - 1; k >= 0; k--) {
        if (loc_list[i] >= loc_rec[j]) {
            loc_merge[k] = loc_list[i];
            i--;
        } else {
            loc_merge[k] = loc_rec[j];
            j--;
        }
    }
    
    memcpy(loc_list, loc_merge, loc_n*sizeof(int));
    
} /* Merge_high */

/*---------------------------------------------------------------------
 * Function:  Get_args
 * Purpose:   Get the command line arguments
 * In args:   argc, argv
 * Out args:  n_p:  pointer to list size
 *            ig_p:  pointer to 'i' if user will input list,
 *            otherwise pointer to '
 */
void Get_args(int argc, char* argv[], int* n_p, char* ig_p, int my_rank) {
    
    if (argc != 3) {
        fprintf(stderr, "usage: %s <n> <'i'|'g'>\n", argv[0]);
        fprintf(stderr, "   n = number of elements in the list (a power of 2)\n");
        fprintf(stderr, "   'i':  user will enter list (no quotes)\n");
        fprintf(stderr, "   'g':  program should generate list (no quotes)\n");
        exit(0);
    }
    
    *n_p = strtol(argv[1], NULL, 10);
    *ig_p = argv[2][0];
    
}  /* Get_args */

/*---------------------------------------------------------------------
 * Function:  Read_n
 * Purpose:   Read in the number of rows in the matrix on process 0
 *            and broadcast this value to the other processes
 * In args:   my_rank:  the calling process' rank
 *            comm:  Communicator containing all calling processes
 * Ret val:   n:  the number of rows in the matrix
 */
int Read_n(int my_rank, MPI_Comm comm) {
    
    int n;
    
    if (my_rank == 0) {
        printf("Please enter the number of elements in your array\n");
        scanf("%d", &n);
    }
    MPI_Bcast(&n, 1, MPI_INT, 0, comm);
    
    return n;
    
}  /* Read_n */

/*---------------------------------------------------------------------
 * Function:  Print_loc
 * Purpose:   Prints each processes' local array with process rank
 * In args:   arr[]: local array to be printed
 *            n: size of array
 *            my_rank: rank of process
 */
void Print_loc(int arr[], int n, int my_rank) {
    
    int i;
    
    printf("my rank: %d -- ", my_rank);
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
}

/*---------------------------------------------------------------------
 * Function:  Print_global
 * Purpose:   Prints global array
 * In args:   arr[]: array to be printed
 *            n: size of array
 */
void Print_global(int arr[], int n) {
    
    int i;
    
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
}

/*---------------------------------------------------------------------
 * Function:  Read_array
 * Purpose:   Take in user input and create an array
 * In args:   n:  the number of elements in the global array
 *            arr : array to be populated
 * Out arg:   arr:  the array that is entered through stdin
 */
void Read_array(int global[], int n, int my_rank, int loc_n, int loc_list[],
                MPI_Comm comm) {
    
    int i;
    
    if (my_rank == 0) {
        for (i = 0; i < n; i++) {
            scanf("%d", &global[i]);
        }
    }
    
    MPI_Scatter(global, loc_n, MPI_INT, loc_list, loc_n, MPI_INT, 0, comm);
    
}  /* Read_array */

/*---------------------------------------------------------------------
 * Function:   Gen_list
 * Purpose:    Use a random number generator to generate an n-element
 *             list
 * In arg:     global: list to be printed
 *             n: size of array
 *             my_rank: rank of each process
 *             loc_n: size of each processes' subarray
 *             loc_list: each processes' local subarray
 *             comm: Communicator containing all calling processes
 * Out arg:    A
 * Note:       Elements of the list are in the range 1 -- KEY_MAX
 */
void Gen_list(int global[], int n, int my_rank, int loc_n, int loc_list[],
              MPI_Comm comm) {
    
    int i;
    
    if (my_rank == 0) {
        srandom(1);
        for (i = 0; i < n; i++)
            global[i] = 1 + random() % KEY_MAX;
    }
    
    MPI_Scatter(global, loc_n, MPI_INT, loc_list, loc_n, MPI_INT, 0, comm);
    
}  /* Gen_list */

/*---------------------------------------------------------------------
 * Function:     compare
 * Purpose:      helper method to sort lists
 * In/out args:  a: pointer to int
 *               b: pointer to in
 */
int compare (const void * a, const void * b) {
    
    return ( *(int*)a - *(int*)b );
    
}